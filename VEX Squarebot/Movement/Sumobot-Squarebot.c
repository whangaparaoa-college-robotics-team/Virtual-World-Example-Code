#pragma config(Motor,  port2,           RightMotor,    tmotorVex269_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           LeftMotor,     tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port6,           ArmMotor,      tmotorVex269_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


//Written by Benjamin Mueggenburg 
// Coast Robotics - Whangaparaoa College
// Written on the 31/10/2017 (31st of November 2017)
// This is the last session of robotics of the year so all goes well


//TRIBUTE TO COAST ROBOTICS
//THANK YOU MR WATTS




//This function is responsible for allowing for cleaner code 
// It will just drive forward. If 'Foward' is true then the robot moves
// forward if it is false then the robot will move backwards. Delaytime is the time
// (in milliseconds, 1000 milliseconds = 1 second) between turning on the motors
// to a speed of 125 and then turning them off
void DriveForward(bool Forward, int delaytime) {
	//If the boolean 'forward' is false
	//The programmer wants the robot to move backwards
	if (Forward == false) {
		motor[LeftMotor] = -125;
		motor[RightMotor] = -125;
		wait1Msec(delaytime);
		motor[LeftMotor] = 0;
		motor[RightMotor] = 0;
	}
	//If the boolean 'forward' is not false then it must be true so
	//The programmer wants the robot to move foward now
	else {
		motor[LeftMotor] = 120;
		motor[RightMotor] = 125;
		wait1Msec(delaytime);
		motor[LeftMotor] = 0;
		motor[RightMotor] = 0;		
	}

}

//Main function - will only run once
task main(){
	//Makes the arm of the square bot go down
	//This will allow the robot to push the obstacles (which look like soda cans)
	//A lot better then if it will up. This also prevents the obstacles getting
	//Stuck underneath the arm
	motor[ArmMotor] = 127;
	wait1Msec(500);
	motor[ArmMotor] = 0;
	
	//DriveTime is an interger which is in milliseconds
	//It specifies how long each of the DriveFowards loops will be
	// I could of typed them individually into the two DriveForward function calls
	//But this means I only have to change DriveChange, for the program to change the
	//Two Driveforward function calls. This saves time during debug
	int DriveTime = 3000;
	//Drives forward - far enought to reach the obstacles 
	//But cannot push them as it gets stuck
	DriveForward(true, DriveTime);
	
	//This block of code will make the robot turn slightly back into the left
	//This is needed because intially the obstacles are slightly to the left
	//Also the intial drive (the line of code just above) causes the robot
	//To slightly swerve left, so this acts as a countersteer
	motor[LeftMotor] = 125;
	motor[RightMotor] = -125;
	wait1Msec(50);
	motor[LeftMotor] = 125;
	motor[RightMotor] = -125;
	
	//Once the robot is now directly in line with the obstacles
	//All it needs to do is just push them out of the circle (or sudo ring)
	//Hence the name 'Sudo bot'. This line will cause the robot to drive foward
	//And just push the obstacles out of the ring
	DriveForward(true, DriveTime);
	

}
